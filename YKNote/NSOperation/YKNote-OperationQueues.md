# 操作队列

Cocoa操作（operation）是一种面向对象的方式来封装您想要异步执行的工作。操作被设计用来和操作队列（operation queue）一起使用或者由他们自己使用。因为他们是基于Objective-C，操作常用于基于Cocoa的OS X和iOS应用程序。

下面介绍如何定义和使用操作。



### 关于操作对象

操作对象是`NSOperation`类（在Foundation框架中）的实例，使用它来封装您想要您应用程序执行的工作。`NSOperation`类本身是一个抽象基类，必须将其子类化才能做任何有用的工作。尽管是抽象的，这个类确实提供了大量的基础结构，以减少您在自己子类中的工作量。此外，基础框架提供了两个具体子类，您可以和您已经存在的代码一样使用。下标列出了这些类，和一些怎么使用他们的摘要信息。

| 类                     | 描述                                       |
| --------------------- | ---------------------------------------- |
| NSInvocationOperation | 您可以使用此类从您应用程序中基于一个对象（object）和选择器（selector）创建一个操作对象。如果已经存在一个执行任务所需要的方法，您可以使用此类。因为它不需要子类化，您也可以以更动态的方式使用此类创建操作对象。有关如何使用这个类的信息，请参阅[创建NSInvocationOperation对象](#创建NSInvocationOperation对象)。 |
| NSBlockOperation      | 您可以使用此类并发的执行一个或者多个块对象（block object）。因为太可以执行多个块，所以块操作对象使用组语义操作。只有当所有相关联的块都执行完成时，操作本身才被认为完成操作。有关如何使用这个类的信息，请参阅[创建NSBlockOperation对象](#创建NSBlockOperation对象)。 |
| NSOperation           | 用于定义自定义操作对象的基类，子类化`NSOperation`给你完全的控制权来实现您自己的操作，包括改变操作执行的默认行为和记录其状态。有关如何定义自定义操作对象的信息，请参阅[定义自定义操作对象](#定义自定义操作对象)。 |



所有操作对象都支持以下主要特性：

- 支持在操作对象间建立基于图的依赖关系。这些依赖关系阻止给定的操作运行，直到它所依赖的所有操作都运行结束。有关如何配置依赖，请参阅[配置并发执行操作](#配置并发执行操作)。
- 支持一个可选的完成块（completion block），在操作的主任务完成后执行。有关如何设置完成块，请参阅[设置完成块](#设置完成块)。
- 支持使用KVO通知监视操作执行状态变化。有关如何观察KVO通知，请参阅[维持KVO规范](#维持KVO规范)。
- 支持优先级操作，从而影响相对执行顺序。欲了解跟多信息，请参阅[更改操作的执行优先级](#更改操作的执行优先级)。
- 支持取消语义，允许您在执行操作时停止操作。有关如何取消操作，请参阅[取消操作](#取消操作)。有关如何在您自己的操作中支持取消，请参阅[响应取消事件](#响应取消事件)。

操作的设计是为了帮助您在您的应用程序中提高并发的级别。操作也是一个很好的方式将您应用程序的行为组织和封装成简单的离散块。你可以提交一个或多个操作对象到队列，并且让相应的工作在一个或多个单独的线程上异步执行，而不是在您应用程序的主线程上运行一些代码。



### 并发操作与非并发操作

虽然您通常通过添加操作到操作队列中来执行操作，但这并不是必须的。也可以通过调用操作对象的`start`方法来手动执行，但这么做并不能保证该操作和您其他的代码并行运行。`NSOperation`类的`isConcurrent`方法告诉您操作与调用`start`方法的线程是同步还是异步运行。默认情况下，该方法返回NO，这意味着操作在调用线程中同步运行。

如果您想实现并发操作（也就是说一个和调用线程异步执行的操作），您必须写一些额外的代码来异步开始操作。例如，您可能产生一个独立的线程，调用一个异步的系统功能，或者做一些其他事情来确保`start`方法开始执行任务，并且很有可能在任务执行结束之前就立即返回。

大多数开发人员应该从不需要实现并发操作对象。如果您总是添加操作到操作队列，则不需要实现并发操作。当您提交一个非并发操作到操作队列时，队列本身会创建一个线程来运行您的操作。因此，添加一个非并发操作到队列，结果仍然会异步执行您操作对象中的代码。只有在您需要异步执行操作又不添加操作到队列的地方才需要定义并发操作。

有关如何创建并发操作，请参阅[配置并发执行操作](#配置并发执行操作)和[NSOperation类参考](https://developer.apple.com/reference/foundation/operation)



### 创建NSInvocationOperation对象

`NSInvocationOperation`类是`NSOperation`类的具体子类，当运行时，在您指定的对象上调用您指定的选择器（selector）。使用此类来避免在您应用程序中为每个任务定义大量的自定义操作对象。特别是如果您正在修改现有的应用程序，并且已经有了执行必要任务所需要的方法和对象。当您想要根据情况能够改变调用方法时，您也可以使用它。例如，您可能使用一个调用操作，基于用户的输入来动态选择来执行一个选择器（selector）。

创建调用操作的过程是简单的。您创建并初始化此类的一个新的实例，传递需要的对象和需要执行的选择器到初始化方法。下面代码给出了演示创建过程的自定义类的两个方法。`taskWithData:`方法创建一个新的调用对象，并且用另一个方法的名字提供给他，此方法包含任务的实现。

```objc
@implementation MyCustomClass
- (NSOperation*)taskWithData:(id)data {
    NSInvocationOperation* theOp = [[NSInvocationOperation alloc] initWithTarget:self
                    selector:@selector(myTaskMethod:) object:data];
 
   return theOp;
}
 
// 这是执行任务实际工作的方法.
- (void)myTaskMethod:(id)data {
    // 执行任务.
}
@end
```



### 创建NSBlockOperation对象

`NSBlockOperation`类是`NSOperation`类的具体子类，它为一个或多个块对象（block object）充当封装器。这个类为已经使用操作队列并且也不想创建调度队列的应用程序提供一个面向对象的封装器。您也可以使用块操作来利用操作依赖，KVO和可能不适用于调度队列的其他特性。

当您创建一个块操作时，您通常在初始化时添加至少一个块，您稍后可以根据需要添加更多的块。当`NSBlockOperation`对象到了执行的时间时，块操作对象提交它所有的块到一个默认优先级的并发调度队列。块操作对象然后等待，直到所有的块完成执行。当最后一个块结束执行的时候，操作对象标记自己为已完成。因此，您可以使用快操作来跟踪一组执行块，就像使用一个线程连接合并多个线程的结果一样。区别是，因为块操作本身运行在一个独立的线程上，当等待块操作完成时您应用程序的其他线程可以继续工作。

下面代码显示了如何创建`NSBlockOperation`对象的简单例子。块本身没有参数也没有有意义的返回结果。

```objc
NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{
      NSLog(@"Beginning operation.\n");
      // 做一些工作.
   }];
```

创建块操作对象后，你可以使用`addExecutionBlock:`方法添加更多块到操作对象。如果您需要串行的执行块，您必须将他们直接提交到期望的调度队列。



### 定义自定义操作对象

如果块操作和调用操作对象不能够完全满足您应用程序的需求，您可以直接子类化`NSOperation`，并添加您需要的任何行为。`NSOperation`类为所有操作对象提供通用的子类化点。该类也提供大量有意义的基础结构为依赖和KVO通知处理大部分工作。然而，有时可能仍然需要您补充实现现有的基础结构，以确保您的操作行为是正确的。您必须做的额外工作的工作量，取决于您实现的是非并发操作还是并发操作。

定义非并发操作比定义并发操作简单的多。对于非并发操作，所有您只需要执行主要任务并且适当的响应取消事件；现有的类基础结构为您处理其他所有工作。对于并发操作，您必须使用自定义代码替换一些现有的基础结构。以下部分为您说明怎么实现两种类型的对象。



#### 执行主要任务

每个操作对象应该至少实现以下方法：

- 一个自定义的初始化方法
- `main`

您需要一个自定义的初始化方法把您的操作对象放到一个已知的状态，和一个自定义的`main`方法来执行您的任务。当然，您可以根据需要实现其他方法，如下所示：

- 您打算从您实现的`main`方法中调用的自定义方法
- 用于设置数据和访问操作结果的存取方法
- 允许您来归档和解档操作对象的`NSCoding`协议方法

下面代码显示了自定义`NSOperation`子类的一个原始模板。（这个代码并没有显示如何处理取消，但显示了您通常会有的方法，有关处理取消的信息，请参阅[响应取消事件](#响应取消事件)。）这个类的初始化方法使用data参数接收一个对象，并且在操作对象内部存储对它的引用。在返回结果到您的应用程序之前，`main`方法可能表现为处理data对象。

```objc
@interface MyNonConcurrentOperation : NSOperation
@property id (strong) myData;
-(id)initWithData:(id)data;
@end
 
@implementation MyNonConcurrentOperation
- (id)initWithData:(id)data {
   if (self = [super init])
      myData = data;
   return self;
}
 
-(void)main {
   @try {
      // Do some work on myData and report the results.
   }
   @catch(...) {
      // Do not rethrow exceptions.
   }
}
@end
```

对于如何实现一个`NSOperation`子类的详细例子，请参阅[NSOperationSample](https://developer.apple.com/library/content/samplecode/NSOperationSample/Introduction/Intro.html#//apple_ref/doc/uid/DTS10004184)



#### 响应取消事件

操作开始执行后，它将继续执行它的任务直到它结束或者直到您的代码明确的取消操作。取消可以发生在任何时间，即使在操作开始执行之前。虽然`NSOperation`为客户取消操作提供一个方法，识别取消事件必然是自动的。如果操作完全终止，则可能无法回收已经分配的资源。因此，期望操作对象能够检查取消事件，并且在操作中发生取消时能够优雅的退出。

为了在操作对象中支持取消，您所要做的就是在您的自定义代码中适时的调用对象的`isCancelled`方法，如果它返回YES，立即返回。不管您的操作持续的时间、您直接继承`NSOperation`或使用其具体子类之一，支持取消都是很重要的。`isCancelled`方法本身是非常轻量的并且可以被频繁调用而没有任何显著的性能损失。当设计您的操作对象时，您应该在您代码的以下地方考虑调用`isCancelled`方法：

- 执行任何实际工作之前立即调用
- 在循环的每次迭代期间至少调用一次，如果每次迭代相对较长，调用多次
- 在您代码可能比较容易终止操作的任何地方调用

以下代码提供了一个简单例子，显示在操作对象的`main`方法中如何相应取消事件。在这种情况下，`while`循环的每次都调用`isCancelled`方法，在开始工作之前，允许快速退出。

```objc
- (void)main {
   @try {
      BOOL isDone = NO;
 
      while (![self isCancelled] && !isDone) {
          // Do some work and set isDone to YES when finished
      }
   }
   @catch(...) {
      // Do not rethrow exceptions.
   }
}
```

虽然前面的代码不包含清除代码，但您自己的代码应当确保释放由您的自定义代码分配的任何资源。



#### 配置并发执行操作

#### 维持KVO规范

### 自定义操作对象的执行行为

#### 配置相互依赖关系

#### 更改操作的执行优先级

#### 更改基础线程优先级

#### 设置完成块

### 实现操作对象的小贴士

#### 管理操作对象内存

##### 避免Per-Thread存储

##### 根据需要保留对操作对象的引用

#### 处理错误和异常

### 确定操作对象的相应范围

### 执行操作

#### 添加操作到操作队列

#### 手动执行操作

#### 取消操作

#### 等待操作完成

#### 暂停与恢复队列