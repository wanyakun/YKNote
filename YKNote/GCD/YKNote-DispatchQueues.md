## 调度队列

大中央调度（GCD）调度队列是执行任务的强大工具。调度队列允许您相对于调度者异步或者同步的执行任意代码块。您能够使用调度队列来执行几乎所有在单独线程上执行的任务。调度队列的优点是它们比线程代码更简单且更高效。

下面提供了调度队列的简介，以及在应用程序中怎么使用调度队列执行一般的任务。如果您想用使用调度队列替换以及存在的线程代码，请参阅[线程迁移](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW1)。



### 关于调度队列

调度队列是在应用程序中异步并发执行任务的一种简单方法。任务通常是应用程序需要执行的一些工作。例如，您可能定义一个任务来执行一些计算，创建和修改数据结构，处理从文件中读取的数据，或者任意数量的事情。通过放置相应的代码到函数或者块对象中来定义任务，并把他们放到调度队列中。

调度队列是一个类似对象的结构体，它管理您提交给它的任务。所有的调度队列都是先进先出的数据结构。因此，添加到队列的任务始终以添加他们的相同顺序开始执行。GCD自动为您提供一些调度队列，但您可以为特定目的创建其他队列。下表列出了应用程序中可以使用的调度队列以及怎么使用它们。

| 类型    | 描述                                       |
| ----- | ---------------------------------------- |
| 串行    | 串行队列（也称为私有调度队列）以添加它们到队列的顺序每次执行一个任务。当前执行的任务运行在一个被调度队列管理的不同线程上（可以随任务变化）。串行队列经常用于同步访问特殊资源。 您可以根据需要创建尽可能多的串行队列，每个队列相对于其他队列并行运行。也就是说，如果你创建四个串行队列，每个队列同一时间只执行一个任务，但是仍然可以有多达四个任务同时执行，每个队列一个。有关怎么创建串行队列，请参阅[创建串行调度队列](#创建串行调度队列)。 |
| 并行    | 并发队列（也称为一类全局调度队列）同时执行一个或者多个任务，但任务仍然以被添加到队列的顺序开始执行。当前执行的任务运行在被调度队列管理的不同线程上。在给定的时间点执行的任务数量是可变的，并且取决于系统调节。在iOS5及以后，你可以通过指定队列类型为DISPATCH_QUEUE_CONCURRENT来自己创建并发队列。此外，还有四个预定义的全局并发队列供应用程序使用。有关怎么回去全局并发队列，请参[阅获取全局并发队列](#阅获取全局并发队列)。 |
| 主调度队列 | 主调队队列是一个全局可用的串行队列，它在应用程序的主线程上执行任务。这个队列与应用程序的RunLoop（如果存在）交错处理排队的任务以及添加到RunLoop的其他事件源。因为它运行在程序的主线程上，所以主队列经常作为应用程序的关键同步点。虽然您不需要创建主调度队列，但您需要确保您的应用程序适当的释放它。有关如何管理此队列，请参阅[在主线程中执行任务](#在主线程中执行任务)。 |



当向应用程序添加并发时，调度队列提供了优于线程的几个优点。最直接的优点是工作队列编程的简单性。使用线程，您必须编写执行的工作以及创建和管理线程的代码。调度队列使您专注于您实际想要执行的工作上，而不用担心线程的创建和管理。相反，系统会为您处理所有的线程创建和管理。优点是，系统能够比任何单个应用更高效的管理线程。系统可以根据可用资源和当前系统的情况动态调整线程数量。另外，系统通常能够比您自己创线程更快的开始运行您的任务。

虽然您可能认为编写调度队列代码可能是困难的，但是通常编写调度队列比编写线程更简单。编码的关键是设计独立的且可以异步运行的任务。（这实际上对线程和调度队列都是真的。）但是调度队列有可预见性的优点。如果您有两个任务来访问相同的共享资源，但是运行在不同的线程上，每个线程都可以首先修改资源，您可能需要使用锁，以确保这两个任务不能同时修改该资源。使用调度队列，您可以添加两个任务到一个串行队列，以确保在任何给定时间只有一个任务修改资源。这种基于队列的同步比锁更高效，因为锁在有竞争和无竞争的情况下总是需要一个昂贵的内核陷阱，而调度队列主要在应用程序的进程空间中工作，只有在绝对必要时才调用内核。

虽然您可能指出，串行队列中的两个任务不是并发运行，但您必须记住，如果两个线程同时使用锁，线程提供的任何并发都会丢失或者显著减少。更重要的，线程模型需要创建两个线程，这两个线程都占用内核和用户内存空间。调度队列不需要为他们的线程支付相同的内存损失，并且使用的线程保持忙碌且不被阻塞。

谨记以下关于调度队列的一些其他关键点：

- 调度队列相对于其他调度队列并发执行任务。任务的串行限于单个调度队列中的任务。
- 在任何时候系统决定执行任务的数量。因此，在100个不同队列中有100个任务的应用程序可能不会同时执行这些任务（除非它具有100个或者更多有效的内核）。
- 在选择要启动的新任务时，系统会考虑队列优先级。有关如何设置串行队列的优先级，请参阅为[队列提供清理功能](#队列提供清理功能)。
- 当任务被添加到队列时，任务必须准备好执行。（如果您之前使用过Cocoa操作对象，请注意此行为与操作使用的模型不同）。
- 私有调度队列是引用计数对象。除了在您自己的代码中保留队列之外，请注意调度源也可以附加到队列，并且增加其保留计数。因此，您必须确保所有调度源都被取消，并且所有的保留调用（retain call）都通过适当的释放调用（release call）进行平衡。有关保留和释放队列，请参阅[调度队列的内存管理](#调度队列的内存管理)。有关调度源的更多信息，请参阅[关于调度源](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW12)。

有关操作调度队列的接口，请参阅[大中央调度（GCD）参考](https://developer.apple.com/reference/dispatch#//apple_ref/doc/uid/TP40008079)。



### 队列相关技术

除了调度队列，GCD提供了几种使用队列来帮助管理代码的技术。下表列出了这些技术，并提供了找到关于它们更多信息的链接。

| 技术                  | 描述                                       |
| ------------------- | ---------------------------------------- |
| Dispatch Group      | 调度组是一种用来监视一组块对象完成的方法（您可以根据需要同步或者异步监视）。组为依赖于其他任务完成的代码提供一种有用的同步机制。更多有关使用组的信息，请参阅[等待排队任务组](#等待排队任务组)。 |
| Dispatch semaphores | 调度信号量类似于传统的信号量，但通常更高效。只有当调用线程需要被阻塞时，调度信号量才调用内核，因为信号量不可用。如果信号量可用，则不进行内核调用。有关如何使用调度信号量的例子，请参阅[使用调度信号量来调节有限资源的使用](#使用调度信号量来调节有限资源的使用)。 |
| Dispatch sources    | 调度源生成通知以响应特定类型的系统事件。您可以使用调度源来监视事件，例如进程通信，信号和描述符事件等。当事件发生时，调度源异步的将您的任务代码提交到指定的调度队列进行处理。有关创建和使用调度源的更多信息，请参阅[调度源](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1)。 |



### 使用块实现任务

块对象（Block Object）是基于C语言的功能，可以使用C，Objective-C和C++代码。块使定义独立的工作单元变的简单。虽然他们可能看起来类似函数指针，但块实际上是底层数据结构的表现，类似于对象，由编译器创建和管理。编译器将您提供的代码（以及任何相关数据）打包，并将其封装成可以存在于堆中并传递给应用程序的形式。

块的一个关键优点是它们能够使用自己的词汇作用域之外的变量。当您在函数或者方法中定义块时，块在某些方法充当传统代码块。例如，块可以读取定义在父作用域的变量值。由块访问的变量将被复制到堆上的块数据结构中，因此块可以稍后访问它们。当块被添加到调度队列时，这些值通常必须以只读格式保留。然而，被同步执行的的块也可以使用具有`__block`关键字的变量来返回数据到父作用域。

使用类似于函数指针语法的代码声明内联块。块和函数指针最大的不同是，在块名字之前使用脱字符(^)代替星号(*)。像函数指针一样，可以传递参数给块，从其接收返回值。下面代码展示如何声明和同步执行块。变量`aBlock`被声明为块，接收一个整型参数，没返回值。然后将与该原型匹配的实际块分配给`aBlock`并声明为内联。最后一行立即执行块，将指定证书打印到标准输出。

```objc
int x = 123;
int y = 456;
 
// Block declaration and assignment
void (^aBlock)(int) = ^(int z) {
    printf("%d %d %d\n", x, y, z);
};
 
// Execute the block
aBlock(789);   // prints: 123 456 789
```

下面是设计块时需要注意的一些主要指南的摘要：

- 对于打算使用调度队列异步执行的块，可以安全的从父函数或者方法中获取标量变量并在块中使用它们。然而，不应该试图获取由调用上下文分配和删除的大型结构或者其他基于指针的变量。当块执行时，被该指针引用的内存可能消失。当然，可以自己分配内存（或者对象）并明确的将该内存的所有权交给块。
- 调度队列复制添加给它们的块，并且当它们结束执行时释放块。换句话说，在添加它们到队列之前，您不需要显式的复制块。
- 虽然队列在执行小任务时比原始线程更高效，但仍然有创建块和在队列上执行它们的开销。如果块的工作太少，内联的执行可能比调度到队列成本更低。判断块是否工作太少的方法是使用性能工具收集每个路径的指标，然后进行比较。
- 不要缓存和底层线程相关的数据，并希望从不同的块访问数据。如果同一队列中的任务需要共享数据，使用调度队列的上下文指针来存储数据。 有关如何访问调度队列的上下文数据，请参阅[使用队列存储自定义上下文信息](#使用队列存储自定义上下文信息) 。
- 如果队列创建多个Objective-C对象，则可能需要将块代码的一部分包含在@autorelease块中，以处理这些对象的内存管理。 虽然GCD调度队列具有自己的自动释放池，但它们不能保证何时耗尽这些池。 如果您的应用程序受内存限制，创建自己的自动释放池允许您以定期的时间间隔释放自动释放对象的内存。


有关块的更多信息，包括如何声明和使用它们，请参阅[块编程](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502)。有关怎么添加块到调度队列，请参阅[添加任务到队列](#添加任务到队列)。



### 创建和管理调度队列

在将任务添加到队列之前，必须确定要使用的队列类型以及如何使用它。调度队列可以串行或并发执行任务。此外，如果您对队列有特殊用途，您可以相应地配置队列属性。 以下各节介绍如何创建调度队列并对其进行配置。



#### 获得全局并发调度队列

当有多个任务并行运行时，并发调度队列很有用。并发队列仍然是一个队列，它以先进先出的顺序对任务进行出队，然而，在前面任何任务结束之前并发队列可能出队另外的任务。在任何给定时刻，并发队列执行任务的实际数量是可变的，并且随应用程序情况的变化而变化。许多因素影响并发队列执行的任务数，包括可用核心数，其他进程正在完成的工作量，其他串行调度队列中任务数量和优先级。

系统为每个应用程序提供四个并发调度队列。这些队列对应用程序是全局的，并且仅通过优先级来区分。因为它们是全局的，所以不需要显式的创建它们。相反，使用`dispatch_get_global_queue`函数来获取其中一个队列，如下所示：

```objc
dispatch_queue_t aQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
```





#### 创建串行调度队列

#### 在运行时获取公共队列

#### 调度队列的内存管理

#### 使用队列存储自定义上下文信息

#### 为队列提供清理功能

### 添加任务到队列

#### 将单个任务添加到队列

#### 任务完成时执行完成块

#### 并发执行循环迭代

#### 在主线程中执行任务

#### 在任务中使用Objective-C对象

### 暂停和恢复队列

### 使用调度信号量来调节有限资源的使用

### 等待排队任务组

### 调度队列和线程安全